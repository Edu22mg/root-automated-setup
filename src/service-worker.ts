/// <reference lib="webworker" />

// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules.

import { clientsClaim } from "workbox-core";
import { ExpirationPlugin } from "workbox-expiration";
import { precacheAndRoute, createHandlerBoundToURL } from "workbox-precaching";
import { registerRoute } from "workbox-routing";
import { StaleWhileRevalidate } from "workbox-strategies";

declare const self: ServiceWorkerGlobalScope;

clientsClaim();

// Precache all of the assets generated by the build process.
// Their URLs are injected into the manifest variable below.
precacheAndRoute(self.__WB_MANIFEST);

// Send all navigation requests to index.html
const fileExtensionRegexp = /\/[^/?]+\.[^/]+$/;
registerRoute(
  // Return false to exempt requests from being fulfilled by index.html.
  ({ request, url }: { request: Request; url: URL }) => {
    // If this isn't a navigation, skip.
    if (request.mode !== "navigate") {
      return false;
    }

    // If this is a URL that starts with /_, skip.
    if (url.pathname.startsWith("/_")) {
      return false;
    }

    // If this looks like a URL for a resource, because it contains
    // a file extension, skip.
    if (url.pathname.match(fileExtensionRegexp)) {
      return false;
    }

    // Return true to signal that we want to use the handler.
    return true;
  },
  createHandlerBoundToURL(`${process.env.PUBLIC_URL}/index.html`)
);

// Handle caching the translations
registerRoute(
  ({ url }) =>
    url.origin === self.location.origin &&
    url.pathname.startsWith(`${process.env.PUBLIC_URL}/locales/`),
  // Serve cached translation, then update the cache in the background
  new StaleWhileRevalidate({
    cacheName: "locales",
  })
);

// Handle caching the images outside of the build
registerRoute(
  ({ url }) =>
    url.origin === self.location.origin &&
    url.pathname.startsWith(`${process.env.PUBLIC_URL}/images/`),
  // Serve cached image, then update the cache in the background
  new StaleWhileRevalidate({
    cacheName: "images",
    plugins: [
      // Since the images are just for decoration, nominate them to be cleared first when the cache fills
      new ExpirationPlugin({ purgeOnQuotaError: true }),
    ],
  })
);
